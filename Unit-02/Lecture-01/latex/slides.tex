\documentclass{beamer}

\usetheme{Berlin}
\usecolortheme{Orchid}
\useoutertheme{miniframes}
\setbeamertemplate{navigation symbols}{}

\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{teal},
  showstringspaces=false
}

\title[Python Programming]{Python Programming}
\subtitle{Unit 02 -- Lecture 01: Lists Fundamentals and Comprehensions}
\author{Tofik Ali}
\institute{School of Computer Science, UPES Dehradun}
\date{\today}

\begin{document}

\begin{frame}[fragile]
  \titlepage
  \vspace{0.5em}
  \begin{center}
  \footnotesize Repository: \texttt{https://github.com/tali7c/Python-Programming}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Quick Links}
  \centering
  \hyperlink{sec:core}{\beamerbutton{Core Concepts}}\hspace{1em}
  \hyperlink{sec:demo}{\beamerbutton{Demo}}\hspace{1em}
  \hyperlink{sec:interactive}{\beamerbutton{Interactive}}\hspace{1em}
  \hyperlink{sec:summary}{\beamerbutton{Summary}}
\end{frame}

\begin{frame}[fragile]{Agenda}
  \tableofcontents
\end{frame}

\section{Overview}

\section{Core Concepts}
\label{sec:core}

\begin{frame}[fragile]{Learning Outcomes}
  \begin{itemize}[<+->]
    \item Create lists and access elements using indexing and slicing
    \item Apply core list methods for insertion, deletion, and sorting
    \item Write list comprehensions for concise transformations
    \item Explain and use nested list structures
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{What is a List?}
  \begin{itemize}[<+->]
    \item Ordered collection of items
    \item Mutable (can change after creation)
    \item Allows duplicates and mixed types
    \item Ideal for sequences you need to update
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Creating Lists}
  \begin{itemize}[<+->]
    \item Literal: \texttt{numbers = [2, 4, 6]}
    \item Constructor: \texttt{letters = list("python")}
    \item From range: \texttt{nums = list(range(5))}
    \item Mixed types: \texttt{items = ["A", 3.5, True]}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Indexing}
  \begin{itemize}[<+->]
    \item Zero-based indexing: first element at index 0
    \item Negative indexing counts from the end
    \item Example: \texttt{scores = [80, 92, 75, 88]}
  \end{itemize}
  \vspace{0.4em}
  \begin{lstlisting}[language=Python]
scores = [80, 92, 75, 88]
print(scores[0])   # 80
print(scores[-1])  # 88
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Slicing}
  \begin{itemize}[<+->]
    \item Syntax: \texttt{list[start:stop:step]}
    \item Stop index is excluded
    \item Useful for sublists and stepping
  \end{itemize}
  \vspace{0.4em}
  \begin{lstlisting}[language=Python]
nums = [1, 2, 3, 4, 5, 6]
print(nums[1:4])   # [2, 3, 4]
print(nums[::2])   # [1, 3, 5]
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Core List Methods}
  \small
  \begin{tabular}{ll}
    \toprule
    Method & Purpose \\
    \midrule
    \texttt{append(x)} & Add to end \\
    \texttt{extend(iter)} & Add all items \\
    \texttt{insert(i, x)} & Insert at index \\
    \texttt{remove(x)} & Remove first match \\
    \texttt{pop(i)} & Remove by index \\
    \bottomrule
  \end{tabular}
  \normalsize
  \vspace{0.6em}
  \begin{itemize}[<+->]
    \item Most methods mutate the list in place
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Sorting: \texttt{sort} vs \texttt{sorted}}
  \begin{itemize}[<+->]
    \item \texttt{sort()} modifies the list in place
    \item \texttt{sorted(list)} returns a new list
    \item Use \texttt{sorted} when you must preserve the original
  \end{itemize}
  \vspace{0.4em}
  \begin{lstlisting}[language=Python]
nums = [3, 1, 2]
nums.sort()                 # nums becomes [1, 2, 3]
new_nums = sorted(nums, reverse=True)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{List Operations}
  \begin{itemize}[<+->]
    \item Concatenation: \texttt{[1,2] + [3,4]}
    \item Repetition: \texttt{[0] * 3}
    \item Membership: \texttt{5 in nums}
    \item Length: \texttt{len(nums)}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Pitfall: Aliasing vs Copy}
  \begin{lstlisting}[language=Python]
a = [1, 2, 3]
b = a          # alias (same object)
b.append(99)
print(a)       # [1, 2, 3, 99]
  \end{lstlisting}
  \begin{itemize}[<+->]
    \item Fix: create an independent list copy
  \end{itemize}
  \begin{lstlisting}[language=Python]
b = a.copy()   # or: a[:]
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{List Comprehension}
  \begin{itemize}[<+->]
    \item Compact way to build lists
    \item Pattern: \texttt{[expr for item in iterable if cond]}
  \end{itemize}
  \vspace{0.4em}
  \begin{lstlisting}[language=Python]
squares = [x*x for x in range(6)]
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Comprehension Example}
  \begin{lstlisting}[language=Python]
nums = [3, 4, 7, 8, 10]
result = [n*n for n in nums if n % 2 == 0]
print(result)  # [16, 64, 100]
  \end{lstlisting}
  \begin{itemize}[<+->]
    \item Combine filtering and transformation in one line
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Worked Example: Marks Analyzer (Core Steps)}
  \begin{lstlisting}[language=Python]
marks = [72, 88, 95, 64, 51, 43, 77]

top_three = sorted(marks, reverse=True)[:3]
pass_mark = 50
passing = [m for m in marks if m >= pass_mark]
  \end{lstlisting}
  \begin{itemize}[<+->]
    \item Use \texttt{sorted} to avoid mutating the input list
    \item Use a comprehension to filter by a rule
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Nested Lists}
  \begin{itemize}[<+->]
    \item Lists can contain other lists (2D structures)
    \item Access with two indices: \texttt{matrix[row][col]}
  \end{itemize}
  \vspace{0.4em}
  \begin{lstlisting}[language=Python]
matrix = [[1, 2, 3], [4, 5, 6]]
print(matrix[1][2])  # 6
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Pitfall: Modify While Iterating}
  \begin{itemize}[<+->]
    \item Removing items while iterating can skip elements
    \item Prefer building a new list (filter) or iterate over a copy
  \end{itemize}
  \vspace{0.4em}
  \begin{lstlisting}[language=Python]
nums = [1, 2, 3, 4, 5]
nums = [n for n in nums if n % 2 == 1]
print(nums)  # [1, 3, 5]
  \end{lstlisting}
\end{frame}

\section{Demo}
\label{sec:demo}

\begin{frame}[fragile]{Demo: Student Marks Analyzer}
  \begin{itemize}[<+->]
    \item Load a list of marks
    \item Compute average and top 3 scores
    \item Filter passing marks using a comprehension
    \item Extension: compute median as a challenge
  \end{itemize}
  \vspace{0.4em}
  \textbf{Script:} \texttt{demo/list\_marks\_analyzer.py}
\end{frame}

\section{Interactive}
\label{sec:interactive}

\begin{frame}[fragile]{Checkpoint 1}
  Which of these returns a new list instead of mutating?
  \begin{enumerate}[<+->]
    \item \texttt{append}
    \item \texttt{sort}
    \item \texttt{sorted}
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Checkpoint 2}
  Write a list comprehension to square only even numbers from
  \texttt{nums = [1,2,3,4,5,6]}.
\end{frame}

\begin{frame}[fragile]{Think-Pair-Share}
  When is a \textbf{for-loop} clearer than a list comprehension?
  Give a short example and justify your choice.
\end{frame}

\section{Summary}
\label{sec:summary}

\begin{frame}[fragile]{Summary}
  \begin{itemize}[<+->]
    \item Lists are ordered, mutable collections
    \item Indexing/slicing enable flexible access
    \item Methods like \texttt{append} and \texttt{sort} mutate lists
    \item Comprehensions build lists concisely
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Exit Question}
  What slice returns the last three items of a list \texttt{data}?
\end{frame}

\end{document}
